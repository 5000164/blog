<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2018s on 5000164 is here</title>
    <link>http://blog.5000164.jp/2018/</link>
    <description>Recent content in 2018s on 5000164 is here</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 19 Jan 2018 22:46:52 +0900</lastBuildDate>
    
	<atom:link href="http://blog.5000164.jp/2018/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ブログを WordPress 👉 Octopress 👉 Hugo と変えてきて記事の書式がバラバラだったのをある程度整えた時の作業ログ 🗒️</title>
      <link>http://blog.5000164.jp/2018-01-format/</link>
      <pubDate>Fri, 19 Jan 2018 22:46:52 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-format/</guid>
      <description>古い記事のメンテとかはしていないんだけど、ブログのデザインを変えた時に見てみたら思ったよりも崩れていたのでまとめてある程度修正することにした。 まだ崩れてる記事とかもあるけど、ひとつひとつ見ていくのは大変なので正確さではなくざっくりなんとなくを目的として作業を行う。 💡 前提となる記事の状態 ブログの記事の書き方は以下の変遷を辿ってきた。 WordPress で始めた最初は HTML を直接書いていた 途中から WordPress に Markdown のプラグインを入れて Markdown で書いていた ブログを Octopress に変えたが WordPress の記事はインポートしなかった 見出しの書き方を ## ではなく --- のように書いていた 見出しレベルは h1 から h3 まで使っていた ブログを Hugo に変えたタイミングで WordPress と Octopress の記事をインポートした 見出しの書き方を ## にした 本文での見出しレベルは h2 だけを使うようにした という状態で時期によって記事の書き方がごちゃごちゃ。 😩 見方 使用したツールは WebStorm 👇 の上側が正規表現での置換対象で、下側が置換内容 3 連</description>
    </item>
    
    <item>
      <title>Scala で JavaFX の Casvas の内容を画像として保存する</title>
      <link>http://blog.5000164.jp/2018-01-scala_javafx_save_image/</link>
      <pubDate>Mon, 15 Jan 2018 20:35:10 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-scala_javafx_save_image/</guid>
      <description>昨日の記事 の続きのようなもの。 Canvas で表示できるようになったから画像として保存する。 コードはこんな感じ。 123456789101112131415161718 val c = new Canvas(300, 300) val gc = c.getGraphicsContext2D gc.setFill(Color.GRAY) gc.setFont(Font.font(&amp;#34;Hiragino Sans&amp;#34;, 20)) gc.fillText(&amp;#34;テキスト&amp;#34;, 50, 50) val wi = new WritableImage(300, 300) c.snapshot(null, wi) val ri = SwingFXUtils.fromFXImage(wi, null) val f = new File(&amp;#34;test.png&amp;#34;) ImageIO.write(ri, &amp;#34;png&amp;#34;, f) val root = new StackPane() root.getChildren.add(c) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() これを実行するとこういう画像ファイルが生成される。 生成された画像 ざっくり説明 Canvas の内容を WritableImage に変換する。 これが Canvas が持ってる snapshot というメソッドでできるっぽい。 その後は RenderedImage に変換してファイルに保存する。 参考 Java-Buddy: Save Canvas to PNG file JavaFX 2 Snapshot as PNG Image | code.makery.ch ついでに保存場所選択 下記のコードを追加することで保存する場所を選べるようになった。 12 val fc = new FileChooser val f = fc.showSaveDialog(primaryStage)</description>
    </item>
    
    <item>
      <title>Scala で JavaFX の Canvas でテキストを表示する</title>
      <link>http://blog.5000164.jp/2018-01-scala_javafx_generate_image/</link>
      <pubDate>Sun, 14 Jan 2018 08:53:55 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-scala_javafx_generate_image/</guid>
      <description>昨日の記事 ではすでに存在する画像を表示したが、やりたいことは生成したテキストを画像にするということだったので、まずはテキストを表示できるようにする。 最終的には画像にしたいので、画像に変換できる Canvas を利用する。 コードはこんな感じ。 1234567891011 val c = new Canvas(300, 300) val gc = c.getGraphicsContext2D gc.setFill(Color.GRAY) gc.setFont(Font.font(&amp;#34;Hiragino Sans&amp;#34;, 20)) gc.fillText(&amp;#34;テキスト&amp;#34;, 50, 50) val root = new StackPane() root.getChildren.add(c) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() このコードで下記のような実行結果になる。 実行結果 参考 JavaFX 図形・Canvas｜軽Lab canvas - JavaFX GraphicsContext change text size - Stack Overflow 試行錯誤メモ 調べていたら WritableImage というもので画像を生成できると見かけたので最初は WritableImage で画像を表示してみたのだが、テキストを描画する方法がわからず、さらに調べていたら Canvas を発見したので Canvas を使用するようにした。 試行錯誤中に参考にしたもの Java-Buddy: Draw something on WritableImage Java Code Example javafx.scene.image.WritableImage</description>
    </item>
    
    <item>
      <title>Scala で JavaFX を使って画像を表示する</title>
      <link>http://blog.5000164.jp/2018-01-scala_javafx_image/</link>
      <pubDate>Sat, 13 Jan 2018 20:59:55 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-scala_javafx_image/</guid>
      <description>こんな感じ。 12345678 val image = new Image(getClass.getResource(&amp;#34;/test.png&amp;#34;).toString) val imageView = new ImageView(image) val root = new StackPane() root.getChildren.add(imageView) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() ポイント 画像を下記のパスに配置して getClass.getResource(&amp;quot;/test.png&amp;quot;).toString でパスを取得すること。 12345 . └── src └── main └── resources └── test.png 参考 java - JavaFx Images Path - Stack Overflow</description>
    </item>
    
    <item>
      <title>Scala の SSL / TLS 通信の中身を見る</title>
      <link>http://blog.5000164.jp/2018-01-view_scala_traffic/</link>
      <pubDate>Fri, 05 Jan 2018 17:48:03 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-view_scala_traffic/</guid>
      <description>Scala の通信の中身が見たい Scala で API を叩くコードを書いた。 ちゃんと API を叩けているのか知りたい、リクエストとレスポンスが見たいと思った。 プロキシーを通す Charles を使ってローカルにプロキシーを立てる。 (Postman も試してみたんだけどレスポンスが自動保存されないっぽい気がして、連続で API を叩いて内容がどんどん変わっていく今回の用途では使えなかった。) HTTP 通信のライブラリとして sttp を使用していたので プロキシーの設定方法 を参考にして下記のように設定する。 1 val backend = HttpURLConnectionBackend(options = SttpBackendOptions.httpProxy(&amp;#34;localhost&amp;#34;, 8888)) これだけで、 HTTP 通信の中身は見られるようになる。 SSL / TLS 通信の中身を見えるようにする SSL / TLS 通信の中身を見るための手順としては Charles の証明書を信頼したキーストアを生成する 生成したキーストアをアプリケーションから読み込む Charles の SSL Proxy を有効にする となる。 Charles の証明書を信頼したキーストアを生成する まず Charles の証明書を取得する。 これはアプリケーションのメニューの Help &amp;gt; SSL Proxying &amp;gt; Save Charles Root Certificate... から取得でき</description>
    </item>
    
  </channel>
</rss>