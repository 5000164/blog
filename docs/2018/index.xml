<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2018s on 5000164 is here</title>
    <link>http://blog.5000164.jp/2018/</link>
    <description>Recent content in 2018s on 5000164 is here</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Mon, 15 Jan 2018 20:35:10 +0900</lastBuildDate>
    
	<atom:link href="http://blog.5000164.jp/2018/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Scala で JavaFX の Casvas の内容を画像として保存する</title>
      <link>http://blog.5000164.jp/2018-01-scala_javafx_save_image/</link>
      <pubDate>Mon, 15 Jan 2018 20:35:10 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-scala_javafx_save_image/</guid>
      <description>昨日の記事 の続きのようなもの。 Canvas で表示できるようになったから画像として保存する。 コードはこんな感じ。 123456789101112131415161718 val c = new Canvas(300, 300) val gc = c.getGraphicsContext2D gc.setFill(Color.GRAY) gc.setFont(Font.font(&amp;#34;Hiragino Sans&amp;#34;, 20)) gc.fillText(&amp;#34;テキスト&amp;#34;, 50, 50) val wi = new WritableImage(300, 300) c.snapshot(null, wi) val ri = SwingFXUtils.fromFXImage(wi, null) val f = new File(&amp;#34;test.png&amp;#34;) ImageIO.write(ri, &amp;#34;png&amp;#34;, f) val root = new StackPane() root.getChildren.add(c) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() これを実行するとこういう画像ファイルが生成される。 生成された画像 ざっくり説明 Canvas の内容を WritableImage に変換する。 これが Canvas が持ってる snapshot というメソッドでできるっぽい。 その後は RenderedImage に変換してファイルに保存する。 参考 Java-Buddy: Save Canvas to PNG file JavaFX 2 Snapshot as PNG Image | code.makery.ch ついでに保存場所選択 下記のコードを追加することで保存する場所を選べるようになった。 12 val fc = new FileChooser val f = fc.showSaveDialog(primaryStage)</description>
    </item>
    
    <item>
      <title>Scala で JavaFX の Canvas でテキストを表示する</title>
      <link>http://blog.5000164.jp/2018-01-scala_javafx_generate_image/</link>
      <pubDate>Sun, 14 Jan 2018 08:53:55 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-scala_javafx_generate_image/</guid>
      <description>昨日の記事 ではすでに存在する画像を表示したが、やりたいことは生成したテキストを画像にするということだったので、まずはテキストを表示できるようにする。 最終的には画像にしたいので、画像に変換できる Canvas を利用する。 コードはこんな感じ。 1234567891011 val c = new Canvas(300, 300) val gc = c.getGraphicsContext2D gc.setFill(Color.GRAY) gc.setFont(Font.font(&amp;#34;Hiragino Sans&amp;#34;, 20)) gc.fillText(&amp;#34;テキスト&amp;#34;, 50, 50) val root = new StackPane() root.getChildren.add(c) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() このコードで下記のような実行結果になる。 実行結果 参考 JavaFX 図形・Canvas｜軽Lab canvas - JavaFX GraphicsContext change text size - Stack Overflow 試行錯誤メモ 調べていたら WritableImage というもので画像を生成できると見かけたので最初は WritableImage で画像を表示してみたのだが、テキストを描画する方法がわからず、さらに調べていたら Canvas を発見したので Canvas を使用するようにした。 試行錯誤中に参考にしたもの Java-Buddy: Draw something on WritableImage Java Code Example javafx.scene.image.WritableImage</description>
    </item>
    
    <item>
      <title>Scala で JavaFX を使って画像を表示する</title>
      <link>http://blog.5000164.jp/2018-01-scala_javafx_image/</link>
      <pubDate>Sat, 13 Jan 2018 20:59:55 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-scala_javafx_image/</guid>
      <description>こんな感じ。 12345678 val image = new Image(getClass.getResource(&amp;#34;/test.png&amp;#34;).toString) val imageView = new ImageView(image) val root = new StackPane() root.getChildren.add(imageView) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() ポイント 画像を下記のパスに配置して getClass.getResource(&amp;quot;/test.png&amp;quot;).toString でパスを取得すること。 12345 . └── src └── main └── resources └── test.png 参考 java - JavaFx Images Path - Stack Overflow</description>
    </item>
    
    <item>
      <title>Scala の SSL / TLS 通信の中身を見る</title>
      <link>http://blog.5000164.jp/2018-01-view_scala_traffic/</link>
      <pubDate>Fri, 05 Jan 2018 17:48:03 +0900</pubDate>
      
      <guid>http://blog.5000164.jp/2018-01-view_scala_traffic/</guid>
      <description>Scala の通信の中身が見たい Scala で API を叩くコードを書いた。 ちゃんと API を叩けているのか知りたい、リクエストとレスポンスが見たいと思った。 プロキシーを通す Charles を使ってローカルにプロキシーを立てる。 (Postman も試してみたんだけどレスポンスが自動保存されないっぽい気がして、連続で API を叩いて内容がどんどん変わっていく今回の用途では使えなかった。) HTTP 通信のライブラリとして sttp を使用していたので プロキシーの設定方法 を参考にして下記のように設定する。 1 val backend = HttpURLConnectionBackend(options = SttpBackendOptions.httpProxy(&amp;#34;localhost&amp;#34;, 8888)) これだけで、 HTTP 通信の中身は見られるようになる。 SSL / TLS 通信の中身を見えるようにする SSL / TLS 通信の中身を見るための手順としては Charles の証明書を信頼したキーストアを生成する 生成したキーストアをアプリケーションから読み込む Charles の SSL Proxy を有効にする となる。 Charles の証明書を信頼したキーストアを生成する まず Charles の証明書を取得する。 これはアプリケーションのメニューの Help &amp;gt; SSL Proxying &amp;gt; Save Charles Root Certificate... から取得でき</description>
    </item>
    
  </channel>
</rss>