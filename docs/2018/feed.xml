<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2018 on 5000164 is here</title><link>https://blog.5000164.jp/2018/</link><description>Recent content in 2018 on 5000164 is here</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Wed, 01 Aug 2018 06:38:16 +0900</lastBuildDate><atom:link href="https://blog.5000164.jp/2018/feed.xml" rel="self" type="application/rss+xml"/><item><title>生きる意味を求めすぎているのかも知れない</title><link>https://blog.5000164.jp/2018/8/1/reason/</link><pubDate>Wed, 01 Aug 2018 06:38:16 +0900</pubDate><guid>https://blog.5000164.jp/2018/8/1/reason/</guid><description>1 年ほど英語を勉強しようと思っている。 現在 29 歳、これからのキャリアを考える時期になぜ英語を勉強するのか？ 英語を勉強することによって学習の効率が上がり、このまま勉強するよりも成長できると考えたから。 という理由だと自分では思っていた。 でもそうじゃないのかも知れない。 言われて納得したことだが、今日本語で学んでる勉強量と同じ勉強量を英語で学んだところで大して違いは生まれない。 如実に差が現れるほど勉強できていない。 悔しいがこの現実は直視しなければならない。 それでもやはり英語を勉強したいと思っている。 そこに理由なんてないのかも知れない。 やってみたいから、やる。 ただそれだけなのかも知れない。 自分の行動にはすべて意味がある、理由がある、合理的である、そういったありもしない正しさを求めてしまっているのかも知れない。 なにかから自分を守るための言い訳として。 それらはきっと後付けの理由で、ただの都合のいいストーリ</description></item><item><title>Charles の一覧から特定の拡張子を除外する</title><link>https://blog.5000164.jp/2018/7/18/charles/</link><pubDate>Wed, 18 Jul 2018 23:23:36 +0900</pubDate><guid>https://blog.5000164.jp/2018/7/18/charles/</guid><description>Charles の一覧から特定の拡張子を除外することができた。 Filter は Settings から正規表現を有効にすると正規表現で絞り込めるようになる。 この正規表現でどうやら否定的先読みが使えるようだったので、下記のように絞り込むことで特定の拡張子を除外することができた。 1 ^https://blog\.5000164\.jp(?!.*(\.css|\.js|\.png|\.gif|\.ttf|\.woff|\.woff2)).*$</description></item><item><title>Karabiner-Elements を使って Mistel Barocco の設定をするようにした</title><link>https://blog.5000164.jp/2018/6/9/keyboard/</link><pubDate>Sat, 09 Jun 2018 15:59:12 +0900</pubDate><guid>https://blog.5000164.jp/2018/6/9/keyboard/</guid><description>Mistel Barocco はキーボード単体でキーの設定を行うことができる。 しかし設定の仕方を毎回忘れてしまうし、設定するのも手間なので、 Mistel Barocco 本体ではできるだけ設定をしないようにして Karabiner-Elements でキーの設定を行うことにした。 fn キーだけはキーボード本体で設定しないといけないので、そこだけ本体で設定する。 あとは Karabiner-Elements の設定をエクスポートして GitHub などにあげておく予定である。 fn キーの設定方法だけメモを残しておく。 fn キーの設定方法 fn + 左 Shift 3 秒間長押し LED が赤く点滅したら離して fn キーを押す fn を設定したいキーを押す 自分は左下の ctrl キーを fn キーにしている リンク tekezo/Karabiner-Elements: Karabiner-Elements is a powerful utility for keyboard customization on macOS Sierra (10.12) or later.</description></item><item><title>謙虚・尊敬・信頼を忘れずにやっていきたい - 本「Team Geek ――Googleのギークたちはいかにしてチームを作るのか」の感想</title><link>https://blog.5000164.jp/2018/6/3/team-geek/</link><pubDate>Sun, 03 Jun 2018 17:28:56 +0900</pubDate><guid>https://blog.5000164.jp/2018/6/3/team-geek/</guid><description>前々から読みたいと思っていたのでついに読んだ。 HRT について、文化について、勉強になった。 謙虚・尊敬・信頼を忘れずにやっていきたい。 読書メモ 人間は断続的なバグの大きな塊だ 自分のバグを修正したかったらダメなところを気づかせてもらう 自分がコントロールできる変数は自分自身 謙虚・尊敬・信頼 HRT の文化を育んでいく 文化がない状態では建設的な批判などができなくなる 自分のやり方でやる、というエゴを通すために多大なコストを払う価値があるか考える チームは個人の生産性や幸福に直接影響する ソフトウェア開発はチームスポーツである 個室が必要なのではなく、ノイズや邪魔を除外する 集中したいときは集中できるようにする仕組みを作る 特定の合い言葉やヘッドフォンやぬいぐるみで意思表示をするなど もちろん集中したまとまった時間が必要だが、チームには素早い接続が必要 過ちから学ぶには失敗を文書化する チームには文化がある 文化は創業者や初期メンバ</description></item><item><title>チャットツールは Slack で分報、 Twist で相談、という二刀流が最強の構成じゃないかと想像してる</title><link>https://blog.5000164.jp/2018/6/2/tool/</link><pubDate>Sat, 02 Jun 2018 18:09:01 +0900</pubDate><guid>https://blog.5000164.jp/2018/6/2/tool/</guid><description>前に書いたこの記事 チャットはコンテキストを適切に分けることが大事、分報とリアクションの組み合わせで心理的安全性の構築に役立てる | 5000164 is here では具体的なツールの話はしなかった。 ここでは具体的なツールとその使い分けについて想像していることを書く。 使うことを想定しているツール 下記の 2 つのツールの組み合わせがいいのではと考えている。 各ツールの特徴と使い分ける理由については後述する。 Slack: Where work happens Twist – Mindful Team Communication Slack のメリット 全体的に使いやすい カスタム絵文字として好きな絵文字を登録できる カスタム絵文字でリアクションできるのがいい リアクションが Activity で簡単に見れるのがいい Slack デメリット コンテキストが区切りやすいわけではない 会話が簡単に混ざってしまう 話題ごとにいちいちチャンネルを作るのが手間 チャンネルを作るたびに誰をチャンネルに追加すればいいのか考えるのが手間 スレッドが使いにくい Slack から感じる思想 書くコストを下げる (その代わり読</description></item><item><title>Apple Music で BGM にいい感じのプレイリストを作る</title><link>https://blog.5000164.jp/2018/6/1/chill/</link><pubDate>Fri, 01 Jun 2018 20:50:43 +0900</pubDate><guid>https://blog.5000164.jp/2018/6/1/chill/</guid><description>Apple Music には毎週自動で内容が更新される Chill Mix というプレイリストがある For You から Chill Mix をライブラリに追加する 追加しといた方がアクセスしやすくなって楽になる 新規でプレイリストを 2 つ作る 曲を溜めていく用のプレイリスト (例: Chill) と、一時的に保管する用のプレイリスト (例: Chill temp) を作る Chill Mix の内容が更新されたら全曲を Chill temp に追加する Chill Mix のプレイリストは編集できないので、気に入らない曲を外すために自分で編集できる Chill temp に入れる Chill Mix をあんまり聞く時間がなかった場合もとりあえず Chill temp に退避しておけば Chill Mix が自動更新されても聞き漏らさない Chill temp を聞いて、気に入らない曲があったらプレイリストから削除する Chill temp をしばらく聞いて、いい感じだったら Chill temp の全曲を Chill に追加して Chill temp を空にする これを繰り返すことでいい感じの曲だけが Chill に溜まっていき、 BGM にいい感じのプレイリストが出来上がる</description></item><item><title>メンションの通知を全員切るべき、という仮説</title><link>https://blog.5000164.jp/2018/5/27/mention/</link><pubDate>Sun, 27 May 2018 16:12:04 +0900</pubDate><guid>https://blog.5000164.jp/2018/5/27/mention/</guid><description>メンションの問題点は通知が飛ぶこと メンションの問題点は「通知が飛ぶこと」ということに尽きる。 通知というのは注意を引いて作業を中断させるものなので、緊急度が高い場合以外には作業の邪魔となる。 しかし「誰に対して発言しているか」という情報は大切である。 でもメンション機能を使用せずに「○○ さん」という書き方をすると見逃しやすくなってしまう。 ソフトメンションとハードメンションという概念 そこで自分はソフトメンションとハードメンションという概念を考えた。 ソフトメンションは、通知が飛ばないメンションである。 ハードメンションは、通知が飛ぶメンションである。 基本的にソフトメンションを使用することで、相手の邪魔をせずに意図を明確にしながら会話が行えるようになると考えられる。 対応しているチャットツールがない しかし現時点で自分が知る限りではソフトメンションとハードメンションという概念を導入しているチャットツールはな</description></item><item><title>設定ファイルを Scala で書く</title><link>https://blog.5000164.jp/2018/5/26/settings/</link><pubDate>Sat, 26 May 2018 15:18:13 +0900</pubDate><guid>https://blog.5000164.jp/2018/5/26/settings/</guid><description>背景 リポジトリに入れたくない情報は別ファイルに設定として書く 型が表現できないのが面倒くさい 目的 Scala で設定ファイルを書けるようにする やり方 Scala で設定を書いて Eval する ディレクトリ構成 1 2 3 4 5 6 7 8 9 10 11 12 . ├── build.sbt └── src └── main ├── resources │ ├── Settings.scala │ └── SettingsSample.scala └── scala ├── infrastructure │ └── Settings.scala └── interfaces └── Application.scala 具体的なコード 依存関係を解決 build.sbt 1 libraryDependencies += &amp;#34;org.scala-lang&amp;#34; % &amp;#34;scala-compiler&amp;#34; % scalaVersion.value 設定を Eval する 設定を表現する infrastructure/Settings.scala 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package infrastructure import scala.io.Source import scala.reflect.runtime.{currentMirror, universe} import scala.tools.reflect.ToolBox object Settings { val toolbox: ToolBox[universe.type] = currentMirror.mkToolBox() val settings: SettingsType = toolbox.eval(toolbox.parse(Source.fromResource(&amp;#34;Settings.scala&amp;#34;).mkString)).asInstanceOf[SettingsType] } trait SettingsType { val hoge: String val foo: Int } 設定を書く resources/Settings.scala 1 2 3 4 5 6 import infrastructure.SettingsType new SettingsType { override val hoge = &amp;#34;hogehoge&amp;#34; override val foo = 1 } 設定のサンプルを書く 設定方法がわかりやすいようにサンプルを SettingsSample として作っておいてリポジトリに含める resources/SettingsSample.scala 1 2 3 4 5 6 import infrastructure.SettingsType new SettingsType { override val hoge = &amp;#34;&amp;#34; override val foo = 0 } 設定がリポジトリに含まれないようにする .gitignore 1 src/main/resources/Settings.scala 使い方 interfaces/Application.scala 1 2 3 4 5 6 7 8 package interfaces import infrastructure.Settings.settings object Application extends App { println(settings.hoge) println(settings.foo) } 現時点での問題点 コンパイルした時に設定ファイルが</description></item><item><title>Scala でコマンドライン引数を分解する</title><link>https://blog.5000164.jp/2018/5/15/command-line/</link><pubDate>Tue, 15 May 2018 20:47:36 +0900</pubDate><guid>https://blog.5000164.jp/2018/5/15/command-line/</guid><description>下記のように書くことでコマンドライン引数を分解できる。 1 2 3 4 5 6 val keyArgs = args.collect { case &amp;#34;--dry-run&amp;#34; =&amp;gt; &amp;#34;dry-run&amp;#34; }.toSet val keyValueArgs = args.sliding(2).toList.collect { case Array(&amp;#34;--date&amp;#34;, specifiedDate: String) =&amp;gt; &amp;#34;date&amp;#34; -&amp;gt; Some(specifiedDate) }.toMap 1 --date &amp;#34;2018-05-15 00:00:00&amp;#34; --dry-run のようなコマンドライン引数を渡した時に keyArgs と keyValueArgs はそれぞれ下記のようになる。 1 2 3 4 5 // keyArgs Set(&amp;#34;dry-run&amp;#34;) // keyValueArgs Map(&amp;#34;date&amp;#34; -&amp;gt; Some(&amp;#34;2018-05-15 00:00:00&amp;#34;))</description></item><item><title>チャットはコンテキストを適切に分けることが大事、分報とリアクションの組み合わせで心理的安全性の構築に役立てる</title><link>https://blog.5000164.jp/2018/5/12/chat/</link><pubDate>Sat, 12 May 2018 00:20:59 +0900</pubDate><guid>https://blog.5000164.jp/2018/5/12/chat/</guid><description>最近チャットのことをよく考えている。 ある程度の認識が自分の中で固まってきたのでここで一旦まとめる。 前提 チャットは難しい。 チャットをうまくしたらすべてが解決するとは思ってなくて、少しでも現状を良くするためのツールとして使う。 チャットのいいところは 読み返すことができる 検索することができる 多くの人が読むことができる 非同期でコミュニケーションができる というところ。 この記事では書いていないこと 2018.5.27 追記 具体的なツールの比較 コンテキストを分ける時にかかるコスト チャットで重要なのはコンテキスト チャットは文字に残ることで複数の人が非同期的にコミュニケーションをとることができるというメリットがある。 このメリットを有効的に使うためにはコンテキストを適切に分ける必要がある。 コンテキストはチャンネル、スレッド、ルームなどで分ける。 コンテキストを適切に分けることで情報のやりとりがスムーズになる。 チャットの種類 一口にチャ</description></item><item><title>Scala から Java ライブラリを使った時のメモ</title><link>https://blog.5000164.jp/2018/4/23/java/</link><pubDate>Mon, 23 Apr 2018 21:18:30 +0900</pubDate><guid>https://blog.5000164.jp/2018/4/23/java/</guid><description>build.sbt でライブラリの追加 1 libraryDependencies += groupID % artifactID % revision のように書く。 最初 Scala の略記法のように %% と書いていたのでうまく動かなかった。 sbt Reference Manual — ライブラリ依存性 型のキャスト Java ライブラリに渡したりするためにキャストする時は asInstanceOf を使う。 また、 1 import collection.JavaConverters._ のようにインポートしておくことで asScala や asJava でコレクションを変換できる。 Scalaのキャスト - Qiita Java と Scala 間のコレクションの変換 | Scala Documentation null を Option に変換 Java ライブラリのメソッドが null を返す場合がある時に、 Option(func(value)) のように Option を使うことで Option 型に変換できる。 値があったら Some(result) が返ってきて、 null だったら None が返ってくるようになる。 Javaとの相互運用 · Scala研修テキスト</description></item><item><title>行動を変えるのは否定ではなく前進である</title><link>https://blog.5000164.jp/2018/4/18/change/</link><pubDate>Wed, 18 Apr 2018 20:36:02 +0900</pubDate><guid>https://blog.5000164.jp/2018/4/18/change/</guid><description>ふと思ったこと。 自分の行動を変えるということに抵抗があるのは、今まで行動してきたことが否定されるような気がするからなんじゃないかと思った。 変化にはコストがかかるから、とかそういう話とは別にして。 否定だと感じてしまう理由 限られた情報の中で選択し続けないといけない。 だから選択を間違えることはよくある。 A と B を比較して、 A を選んだとして、後からやっぱり B がよかったと B に変えたとする。 そうすると、 A を選んでいた期間が間違いだったように感じてしまう。 その期間を否定されたと感じてしまうのではないかと考えた。 行動を変えるのは否定ではなく前進である A を選ぶことで人生に 10 のいいことがあるとして、 B を選ぶことで人生に 15 のいいことがあるとする。 もちろん最初から B を選べることが理想だが、人間は間違えるので、 A を選ぶことだってよくある。 A を選んだ後に B に変えると、 A を選んでいた期間がもったいないと感じてしまう。 後か</description></item><item><title>Basic 認証の realm は正しく設定する</title><link>https://blog.5000164.jp/2018/4/11/basic/</link><pubDate>Wed, 11 Apr 2018 23:16:34 +0900</pubDate><guid>https://blog.5000164.jp/2018/4/11/basic/</guid><description>sbt で Basic 認証がかかっている依存を解決するために ~/.sbt/.credentials に認証情報を書いていたけど、 realm がずれていたせいで認証に失敗するということが起きた。 realm とは領域という意味で、おそらく ~/.sbt/.credentials の host と realm からどの認証情報を使用するのか判断している気がする。 なので、 realm がずれていると認証に失敗する。 HTTP（Hyper Text Transfer Protocol）～後編：インターネット・プロトコル詳説（2） - ＠IT Basic認証 - Wikipedia 正しい realm は curl で確認できる。 1 curl -v &amp;lt;対象の URL&amp;gt; 2&amp;gt;&amp;amp;1 | grep realm ivy - sbt dependency resolver with basic auth - Stack Overflow</description></item><item><title>Bash のデバッグができた</title><link>https://blog.5000164.jp/2018/4/8/bash/</link><pubDate>Sun, 08 Apr 2018 23:14:26 +0900</pubDate><guid>https://blog.5000164.jp/2018/4/8/bash/</guid><description>brew install bashdb で bashdb をインストール Visual Studio Code に Bash Debug を追加 Bash Debug - Visual Studio Marketplace デバッグの設定を追加して実行 これで動いた。 便利。</description></item><item><title>Display Menu を使ったら表示領域が広がって便利</title><link>https://blog.5000164.jp/2018/3/24/display-menu/</link><pubDate>Sat, 24 Mar 2018 21:44:16 +0900</pubDate><guid>https://blog.5000164.jp/2018/3/24/display-menu/</guid><description>今 MacBook Pro を使っていて、画面の表示を Retina 表示のままではなく More Space に設定して表示領域を広くしていたんだけど、最近 Display Menu というアプリを教えてもらった。 これを使うと System Preferences で設定できるよりも表示領域を広くすることができる。 これで今は 2,560 x 1,600 の解像度で表示している。 作業領域が広くなって便利。 2018.5.27 追記 2,560 x 1,600 では見づらくて顔を近づけることが多く、 Mac の設定から変更できる 1,920 x 1,200 で使うようにしたのでアプリは使用しなくなった。 アプリ 「Display Menu」をMac App Storeで 使い方がわかりやすかった記事 MacのRetinaディスプレイを本来の解像度で使えるようにする：Tech TIPS - ＠IT</description></item><item><title>Android のフローティングブラウザを Flynx から Lynket に変えた</title><link>https://blog.5000164.jp/2018/3/18/browser/</link><pubDate>Sun, 18 Mar 2018 22:49:34 +0900</pubDate><guid>https://blog.5000164.jp/2018/3/18/browser/</guid><description>元々は Link Bubble でフローティングブラウザを知り、便利で愛用していたのだが、たしか使えなくなったので代替アプリを探して Flynx を使うようになった。 でも広告をブロックしたかったり、常時パソコン用の表示にしたかったりと思って、ちょいちょいフローティングブラウザは調べていた。 それで今回もたまたま調べていたら、 Chromer というアプリがアップデートで Lynket という名前に変わっていて、改めて使ってみたらいい感じだったので乗り換えることにした。 そもそものフローティングブラウザのよさ 作業を中断せずに続けることができる Twitter を読んでいて、気になったリンクは開いておく、 Twitter を読み終わったら開いていたリンクを読む、ということができる 作業を途切れることなく続けることができていい Lynket のいいところ 同じリンクを多重に開かない あれ、このリンクさっき開いたっけ？と思って念のため開いておく、ってやって無駄にリンクを溜めておくことがなくなる ページを表示したらスタ</description></item><item><title>いいタイミングで読めた - 本「SOFT SKILLS　ソフトウェア開発者の人生マニュアル」の感想</title><link>https://blog.5000164.jp/2018/2/18/soft-skills/</link><pubDate>Sun, 18 Feb 2018 22:19:18 +0900</pubDate><guid>https://blog.5000164.jp/2018/2/18/soft-skills/</guid><description>新しい仕事を探すタイミングで、身の振り方などが勉強になるかもしれないと期待して読み始めた。 この本ではもっと広範な内容を扱っており、とても勉強になった。 1 つ 1 つの章が短くテンポがいいので苦労せずに読むことができた。 今このタイミングでこの本を読むことができてよかった。 これからも生活を改善していけたらいいなと思う。 読書メモ リスペクトとは、相手が大切にされていると感じることかもしれない 自分の時間報酬を考え直した 自分が提供できる価値を明確にする 過去に問題を乗り越えられているのだから、これからも乗り越えられると信じてできると信じる できているふりをして行動することでその理想に近付ける マーケティングとして、先に価値を提供すること 価値がある、誰かの役に立つブログを書く 価値を与えた相手に影響力を持つことができる 自分のブランドを作る ブログのアイディアリストを作る 他人にどうやって価値をもたらすかを常に考える 他人に</description></item><item><title>Hugo のブログの記事の URL を変更した時のログ</title><link>https://blog.5000164.jp/2018/1/21/hugo/</link><pubDate>Sun, 21 Jan 2018 21:33:31 +0900</pubDate><guid>https://blog.5000164.jp/2018/1/21/hugo/</guid><description>ブログの記事の URL を変更した。 今までは blog.5000164.jp/2018-1-format/ のような形式だったものを blog.5000164.jp/2018/1/19/format/ という形式にした。 今までの形式にしていた理由としては、ドメインの直下に記事の URL がぶら下がってるのかっこいい、と思っていたから。 新しい形式にした理由としては、年月日で階層が分かれてたほうがセマンティックでかっこいい、と思ったから。 変更前の状態 記事のファイルの構成は 2018/01/format.md のような感じで年月で分けて、月はゼロ埋めで 2 桁にしてある 記事の URL は url = &amp;quot;2018-01-format&amp;quot; のような感じで記事 1 つ 1 つに設定してある 記事の作成日は date = 2012-10-15T03:16:25+00:00 のような感じで 1 つ 1 つに設定してある 変更後の状態 記事のファイルの構成は 2018/1/19/format.md のような感じで作成日の年月日で分かれるようにして、月日のゼロ埋めはしない 記事の URL は指定せずにディレクトリ構成のままでいくので URL の設定を削除する 過去の URL にアクセスした時に新しい記事にリダイレクトさせる 変更方法 手作業で簡単にできるものじゃないと思ったのでツールを作った。 5000164/hugo-url-converter</description></item><item><title>ブログを WordPress 👉 Octopress 👉 Hugo と変えてきて記事の書式がバラバラだったのをある程度整えた時の作業ログ 🗒️</title><link>https://blog.5000164.jp/2018/1/19/format/</link><pubDate>Fri, 19 Jan 2018 22:46:52 +0900</pubDate><guid>https://blog.5000164.jp/2018/1/19/format/</guid><description>古い記事のメンテとかはしていないんだけど、ブログのデザインを変えた時に見てみたら思ったよりも崩れていたのでまとめてある程度修正することにした。 まだ崩れてる記事とかもあるけど、ひとつひとつ見ていくのは大変なので正確さではなくざっくりなんとなくを目的として作業を行う。 💡 前提となる記事の状態 ブログの記事の書き方は以下の変遷を辿ってきた。 WordPress で始めた最初は HTML を直接書いていた 途中から WordPress に Markdown のプラグインを入れて Markdown で書いていた ブログを Octopress に変えたが WordPress の記事はインポートしなかった 見出しの書き方を ## ではなく --- のように書いていた 見出しレベルは h1 から h3 まで使っていた ブログを Hugo に変えたタイミングで WordPress と Octopress の記事をインポートした 見出しの書き方を ## にした 本文での見出しレベルは h2 だけを使うようにした という状態で時期によって記事の書き方がごちゃごちゃ。 😩 見方 使用したツールは WebStorm 👇 の上側が正規表現での置換対象で、下側が置換内容 3 連</description></item><item><title>Scala で JavaFX の Casvas の内容を画像として保存する</title><link>https://blog.5000164.jp/2018/1/15/scala-javafx-save-image/</link><pubDate>Mon, 15 Jan 2018 20:35:10 +0900</pubDate><guid>https://blog.5000164.jp/2018/1/15/scala-javafx-save-image/</guid><description>昨日の記事 の続きのようなもの。 Canvas で表示できるようになったから画像として保存する。 コードはこんな感じ。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val c = new Canvas(300, 300) val gc = c.getGraphicsContext2D gc.setFill(Color.GRAY) gc.setFont(Font.font(&amp;#34;Hiragino Sans&amp;#34;, 20)) gc.fillText(&amp;#34;テキスト&amp;#34;, 50, 50) val wi = new WritableImage(300, 300) c.snapshot(null, wi) val ri = SwingFXUtils.fromFXImage(wi, null) val f = new File(&amp;#34;test.png&amp;#34;) ImageIO.write(ri, &amp;#34;png&amp;#34;, f) val root = new StackPane() root.getChildren.add(c) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() これを実行するとこういう画像ファイルが生成される。 生成された画像 ざっくり説明 Canvas の内容を WritableImage に変換する。 これが Canvas が持ってる snapshot というメソッドでできるっぽい。 その後は RenderedImage に変換してファイルに保存する。 参考 Java-Buddy: Save Canvas to PNG file JavaFX 2 Snapshot as PNG Image | code.makery.ch ついでに保存場所選択 下記のコードを追加することで保存する場所を選べるようになった。 1 2 val fc = new FileChooser val f = fc.showSaveDialog(primaryStage)</description></item><item><title>Scala で JavaFX の Canvas でテキストを表示する</title><link>https://blog.5000164.jp/2018/1/14/scala-javafx-generate-image/</link><pubDate>Sun, 14 Jan 2018 08:53:55 +0900</pubDate><guid>https://blog.5000164.jp/2018/1/14/scala-javafx-generate-image/</guid><description>昨日の記事 ではすでに存在する画像を表示したが、やりたいことは生成したテキストを画像にするということだったので、まずはテキストを表示できるようにする。 最終的には画像にしたいので、画像に変換できる Canvas を利用する。 コードはこんな感じ。 1 2 3 4 5 6 7 8 9 10 11 val c = new Canvas(300, 300) val gc = c.getGraphicsContext2D gc.setFill(Color.GRAY) gc.setFont(Font.font(&amp;#34;Hiragino Sans&amp;#34;, 20)) gc.fillText(&amp;#34;テキスト&amp;#34;, 50, 50) val root = new StackPane() root.getChildren.add(c) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() このコードで下記のような実行結果になる。 実行結果 参考 JavaFX 図形・Canvas｜軽Lab canvas - JavaFX GraphicsContext change text size - Stack Overflow 試行錯誤メモ 調べていたら WritableImage というもので画像を生成できると見かけたので最初は WritableImage で画像を表示してみたのだが、テキストを描画する方法がわからず、さらに調べていたら Canvas を発見したので Canvas を使用するようにした。 試行錯誤中に参考にしたもの Java-Buddy: Draw something on WritableImage Java Code Example javafx.scene.image.WritableImage</description></item><item><title>Scala で JavaFX を使って画像を表示する</title><link>https://blog.5000164.jp/2018/1/13/scala-javafx-image/</link><pubDate>Sat, 13 Jan 2018 20:59:55 +0900</pubDate><guid>https://blog.5000164.jp/2018/1/13/scala-javafx-image/</guid><description>こんな感じ。 1 2 3 4 5 6 7 8 val image = new Image(getClass.getResource(&amp;#34;/test.png&amp;#34;).toString) val imageView = new ImageView(image) val root = new StackPane() root.getChildren.add(imageView) val scene = new Scene(root, 350, 350) primaryStage.setTitle(&amp;#34;test&amp;#34;) primaryStage.setScene(scene) primaryStage.show() ポイント 画像を下記のパスに配置して getClass.getResource(&amp;quot;/test.png&amp;quot;).toString でパスを取得すること。 1 2 3 4 5 . └── src └── main └── resources └── test.png 参考 java - JavaFx Images Path - Stack Overflow</description></item><item><title>Scala の SSL / TLS 通信の中身を見る</title><link>https://blog.5000164.jp/2018/1/5/view-scala-traffic/</link><pubDate>Fri, 05 Jan 2018 17:48:03 +0900</pubDate><guid>https://blog.5000164.jp/2018/1/5/view-scala-traffic/</guid><description>Scala の通信の中身が見たい Scala で API を叩くコードを書いた。 ちゃんと API を叩けているのか知りたい、リクエストとレスポンスが見たいと思った。 プロキシーを通す Charles を使ってローカルにプロキシーを立てる。 (Postman も試してみたんだけどレスポンスが自動保存されないっぽい気がして、連続で API を叩いて内容がどんどん変わっていく今回の用途では使えなかった。) HTTP 通信のライブラリとして sttp を使用していたので プロキシーの設定方法 を参考にして下記のように設定する。 1 val backend = HttpURLConnectionBackend(options = SttpBackendOptions.httpProxy(&amp;#34;localhost&amp;#34;, 8888)) これだけで、 HTTP 通信の中身は見られるようになる。 2018.5.28 追記 HttpURLConnectionBackend のデフォルト引数が options: SttpBackendOptions = SttpBackendOptions.Default となっていて、なにも設定しなければシステムのプロキシー設定を反映してくれるので 1 val backend: SttpBackend[Id, Nothing] = HttpURLConnectionBackend() のままでいい。 Charles は起動時に自動でシステムのプロキシー設定を書き換えてくれるので、設定がそのまま反映される。 SSL / TLS 通信の中身を見えるようにする SSL / TLS 通信の中身を見るための手順としては Charles の証明書を信</description></item></channel></rss>